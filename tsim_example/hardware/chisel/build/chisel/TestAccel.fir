;buildInfoPackage: chisel3, version: 3.1.7, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-03-20 22:15:13.399, builtAtMillis: 1553120113399
circuit TestAccel : 
  extmodule VTAHostDPI : 
    output dpi : {req : {valid : UInt<1>, opcode : UInt<1>, addr : UInt<8>, value : UInt<32>, flip deq : UInt<1>}, flip resp : {valid : UInt<1>, bits : UInt<32>}}
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTAHostDPI
    
    
  extmodule VTAMemDPI : 
    output dpi : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip len : UInt<8>, flip addr : UInt<64>}, flip wr : {valid : UInt<1>, bits : UInt<64>}, rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTAMemDPI
    
    
  module VTASimShell : 
    input clock : Clock
    input reset : UInt<1>
    output io : {host : {req : {valid : UInt<1>, opcode : UInt<1>, addr : UInt<8>, value : UInt<32>, flip deq : UInt<1>}, flip resp : {valid : UInt<1>, bits : UInt<32>}}, mem : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip len : UInt<8>, flip addr : UInt<64>}, flip wr : {valid : UInt<1>, bits : UInt<64>}, rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    inst host of VTAHostDPI @[TestAccel.scala 36:20]
    host.dpi is invalid
    host.reset is invalid
    host.clock is invalid
    inst mem of VTAMemDPI @[TestAccel.scala 37:19]
    mem.dpi is invalid
    mem.reset is invalid
    mem.clock is invalid
    io.mem.rd.bits <= mem.dpi.rd.bits @[TestAccel.scala 38:14]
    io.mem.rd.valid <= mem.dpi.rd.valid @[TestAccel.scala 38:14]
    mem.dpi.rd.ready <= io.mem.rd.ready @[TestAccel.scala 38:14]
    mem.dpi.wr.bits <= io.mem.wr.bits @[TestAccel.scala 38:14]
    mem.dpi.wr.valid <= io.mem.wr.valid @[TestAccel.scala 38:14]
    mem.dpi.req.addr <= io.mem.req.addr @[TestAccel.scala 38:14]
    mem.dpi.req.len <= io.mem.req.len @[TestAccel.scala 38:14]
    mem.dpi.req.opcode <= io.mem.req.opcode @[TestAccel.scala 38:14]
    mem.dpi.req.valid <= io.mem.req.valid @[TestAccel.scala 38:14]
    mem.reset <= reset @[TestAccel.scala 39:16]
    mem.clock <= clock @[TestAccel.scala 40:16]
    host.dpi.resp.bits <= io.host.resp.bits @[TestAccel.scala 41:11]
    host.dpi.resp.valid <= io.host.resp.valid @[TestAccel.scala 41:11]
    host.dpi.req.deq <= io.host.req.deq @[TestAccel.scala 41:11]
    io.host.req.value <= host.dpi.req.value @[TestAccel.scala 41:11]
    io.host.req.addr <= host.dpi.req.addr @[TestAccel.scala 41:11]
    io.host.req.opcode <= host.dpi.req.opcode @[TestAccel.scala 41:11]
    io.host.req.valid <= host.dpi.req.valid @[TestAccel.scala 41:11]
    host.reset <= reset @[TestAccel.scala 42:17]
    host.clock <= clock @[TestAccel.scala 43:17]
    
  module RegFile : 
    input clock : Clock
    input reset : UInt<1>
    output io : {launch : UInt<1>, flip finish : UInt<1>, flip ecnt : {valid : UInt<1>, bits : UInt<32>}[1], vals : UInt<32>[1], ptrs : UInt<64>[3], host : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip addr : UInt<8>, flip value : UInt<32>, deq : UInt<1>}, resp : {valid : UInt<1>, bits : UInt<32>}}}
    
    reg state : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[RegFile.scala 62:22]
    node _T_68 = eq(UInt<1>("h00"), state) @[Conditional.scala 37:30]
    when _T_68 : @[Conditional.scala 40:58]
      node _T_70 = eq(io.host.req.opcode, UInt<1>("h00")) @[RegFile.scala 66:34]
      node _T_71 = and(io.host.req.valid, _T_70) @[RegFile.scala 66:31]
      when _T_71 : @[RegFile.scala 66:55]
        state <= UInt<1>("h01") @[RegFile.scala 67:15]
        skip @[RegFile.scala 66:55]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_72 = eq(UInt<1>("h01"), state) @[Conditional.scala 37:30]
      when _T_72 : @[Conditional.scala 39:67]
        state <= UInt<1>("h00") @[RegFile.scala 71:13]
        skip @[Conditional.scala 39:67]
    node _T_73 = eq(state, UInt<1>("h00")) @[RegFile.scala 75:28]
    node _T_74 = and(_T_73, io.host.req.valid) @[RegFile.scala 75:38]
    io.host.req.deq <= _T_74 @[RegFile.scala 75:19]
    wire _T_78 : UInt<32> @[RegFile.scala 78:50]
    _T_78 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_0 : UInt, clock with : (reset => (reset, _T_78)) @[RegFile.scala 78:37]
    wire _T_83 : UInt<32> @[RegFile.scala 78:50]
    _T_83 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_1 : UInt, clock with : (reset => (reset, _T_83)) @[RegFile.scala 78:37]
    wire _T_88 : UInt<32> @[RegFile.scala 78:50]
    _T_88 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_2 : UInt, clock with : (reset => (reset, _T_88)) @[RegFile.scala 78:37]
    wire _T_93 : UInt<32> @[RegFile.scala 78:50]
    _T_93 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_3 : UInt, clock with : (reset => (reset, _T_93)) @[RegFile.scala 78:37]
    wire _T_98 : UInt<32> @[RegFile.scala 78:50]
    _T_98 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_4 : UInt, clock with : (reset => (reset, _T_98)) @[RegFile.scala 78:37]
    wire _T_103 : UInt<32> @[RegFile.scala 78:50]
    _T_103 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_5 : UInt, clock with : (reset => (reset, _T_103)) @[RegFile.scala 78:37]
    wire _T_108 : UInt<32> @[RegFile.scala 78:50]
    _T_108 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_6 : UInt, clock with : (reset => (reset, _T_108)) @[RegFile.scala 78:37]
    wire _T_113 : UInt<32> @[RegFile.scala 78:50]
    _T_113 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_7 : UInt, clock with : (reset => (reset, _T_113)) @[RegFile.scala 78:37]
    wire _T_118 : UInt<32> @[RegFile.scala 78:50]
    _T_118 <= UInt<1>("h00") @[RegFile.scala 78:50]
    reg reg_8 : UInt, clock with : (reset => (reset, _T_118)) @[RegFile.scala 78:37]
    when io.finish : @[RegFile.scala 85:20]
      reg_0 <= UInt<2>("h02") @[RegFile.scala 86:12]
      skip @[RegFile.scala 85:20]
    else : @[RegFile.scala 88:63]
      node _T_130 = eq(state, UInt<1>("h00")) @[RegFile.scala 87:22]
      node _T_131 = and(_T_130, io.host.req.valid) @[RegFile.scala 87:32]
      node _T_132 = and(_T_131, io.host.req.opcode) @[RegFile.scala 87:53]
      node _T_134 = eq(UInt<1>("h00"), io.host.req.addr) @[RegFile.scala 88:41]
      node _T_135 = and(_T_132, _T_134) @[RegFile.scala 88:28]
      when _T_135 : @[RegFile.scala 88:63]
        reg_0 <= io.host.req.value @[RegFile.scala 89:12]
        skip @[RegFile.scala 88:63]
    when io.ecnt[0].valid : @[RegFile.scala 93:29]
      reg_1 <= io.ecnt[0].bits @[RegFile.scala 94:19]
      skip @[RegFile.scala 93:29]
    else : @[RegFile.scala 96:70]
      node _T_136 = eq(state, UInt<1>("h00")) @[RegFile.scala 95:24]
      node _T_137 = and(_T_136, io.host.req.valid) @[RegFile.scala 95:34]
      node _T_138 = and(_T_137, io.host.req.opcode) @[RegFile.scala 95:55]
      node _T_140 = eq(UInt<3>("h04"), io.host.req.addr) @[RegFile.scala 96:48]
      node _T_141 = and(_T_138, _T_140) @[RegFile.scala 96:30]
      when _T_141 : @[RegFile.scala 96:70]
        reg_1 <= io.host.req.value @[RegFile.scala 97:19]
        skip @[RegFile.scala 96:70]
    node _T_142 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:17]
    node _T_143 = and(_T_142, io.host.req.valid) @[RegFile.scala 102:27]
    node _T_144 = and(_T_143, io.host.req.opcode) @[RegFile.scala 102:48]
    node _T_146 = eq(UInt<4>("h08"), io.host.req.addr) @[RegFile.scala 103:48]
    node _T_147 = and(_T_144, _T_146) @[RegFile.scala 103:30]
    when _T_147 : @[RegFile.scala 103:70]
      reg_2 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:70]
    node _T_148 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:17]
    node _T_149 = and(_T_148, io.host.req.valid) @[RegFile.scala 102:27]
    node _T_150 = and(_T_149, io.host.req.opcode) @[RegFile.scala 102:48]
    node _T_152 = eq(UInt<4>("h0c"), io.host.req.addr) @[RegFile.scala 103:48]
    node _T_153 = and(_T_150, _T_152) @[RegFile.scala 103:30]
    when _T_153 : @[RegFile.scala 103:70]
      reg_3 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:70]
    node _T_154 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:17]
    node _T_155 = and(_T_154, io.host.req.valid) @[RegFile.scala 102:27]
    node _T_156 = and(_T_155, io.host.req.opcode) @[RegFile.scala 102:48]
    node _T_158 = eq(UInt<5>("h010"), io.host.req.addr) @[RegFile.scala 103:48]
    node _T_159 = and(_T_156, _T_158) @[RegFile.scala 103:30]
    when _T_159 : @[RegFile.scala 103:70]
      reg_4 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:70]
    node _T_160 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:17]
    node _T_161 = and(_T_160, io.host.req.valid) @[RegFile.scala 102:27]
    node _T_162 = and(_T_161, io.host.req.opcode) @[RegFile.scala 102:48]
    node _T_164 = eq(UInt<5>("h014"), io.host.req.addr) @[RegFile.scala 103:48]
    node _T_165 = and(_T_162, _T_164) @[RegFile.scala 103:30]
    when _T_165 : @[RegFile.scala 103:70]
      reg_5 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:70]
    node _T_166 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:17]
    node _T_167 = and(_T_166, io.host.req.valid) @[RegFile.scala 102:27]
    node _T_168 = and(_T_167, io.host.req.opcode) @[RegFile.scala 102:48]
    node _T_170 = eq(UInt<5>("h018"), io.host.req.addr) @[RegFile.scala 103:48]
    node _T_171 = and(_T_168, _T_170) @[RegFile.scala 103:30]
    when _T_171 : @[RegFile.scala 103:70]
      reg_6 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:70]
    node _T_172 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:17]
    node _T_173 = and(_T_172, io.host.req.valid) @[RegFile.scala 102:27]
    node _T_174 = and(_T_173, io.host.req.opcode) @[RegFile.scala 102:48]
    node _T_176 = eq(UInt<5>("h01c"), io.host.req.addr) @[RegFile.scala 103:48]
    node _T_177 = and(_T_174, _T_176) @[RegFile.scala 103:30]
    when _T_177 : @[RegFile.scala 103:70]
      reg_7 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:70]
    node _T_178 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:17]
    node _T_179 = and(_T_178, io.host.req.valid) @[RegFile.scala 102:27]
    node _T_180 = and(_T_179, io.host.req.opcode) @[RegFile.scala 102:48]
    node _T_182 = eq(UInt<6>("h020"), io.host.req.addr) @[RegFile.scala 103:48]
    node _T_183 = and(_T_180, _T_182) @[RegFile.scala 103:30]
    when _T_183 : @[RegFile.scala 103:70]
      reg_8 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:70]
    wire _T_187 : UInt<32> @[RegFile.scala 108:35]
    _T_187 <= UInt<1>("h00") @[RegFile.scala 108:35]
    reg rdata : UInt, clock with : (reset => (reset, _T_187)) @[RegFile.scala 108:22]
    node _T_189 = eq(state, UInt<1>("h00")) @[RegFile.scala 109:15]
    node _T_190 = and(_T_189, io.host.req.valid) @[RegFile.scala 109:25]
    node _T_192 = eq(io.host.req.opcode, UInt<1>("h00")) @[RegFile.scala 109:49]
    node _T_193 = and(_T_190, _T_192) @[RegFile.scala 109:46]
    when _T_193 : @[RegFile.scala 109:70]
      node _T_195 = eq(UInt<6>("h020"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_196 = mux(_T_195, reg_8, UInt<1>("h00")) @[Mux.scala 46:16]
      node _T_197 = eq(UInt<5>("h01c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_198 = mux(_T_197, reg_7, _T_196) @[Mux.scala 46:16]
      node _T_199 = eq(UInt<5>("h018"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_200 = mux(_T_199, reg_6, _T_198) @[Mux.scala 46:16]
      node _T_201 = eq(UInt<5>("h014"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_202 = mux(_T_201, reg_5, _T_200) @[Mux.scala 46:16]
      node _T_203 = eq(UInt<5>("h010"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_204 = mux(_T_203, reg_4, _T_202) @[Mux.scala 46:16]
      node _T_205 = eq(UInt<4>("h0c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_206 = mux(_T_205, reg_3, _T_204) @[Mux.scala 46:16]
      node _T_207 = eq(UInt<4>("h08"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_208 = mux(_T_207, reg_2, _T_206) @[Mux.scala 46:16]
      node _T_209 = eq(UInt<3>("h04"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_210 = mux(_T_209, reg_1, _T_208) @[Mux.scala 46:16]
      node _T_211 = eq(UInt<1>("h00"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_212 = mux(_T_211, reg_0, _T_210) @[Mux.scala 46:16]
      rdata <= _T_212 @[RegFile.scala 110:11]
      skip @[RegFile.scala 109:70]
    node _T_213 = eq(state, UInt<1>("h01")) @[RegFile.scala 113:31]
    io.host.resp.valid <= _T_213 @[RegFile.scala 113:22]
    io.host.resp.bits <= rdata @[RegFile.scala 114:21]
    node _T_214 = bits(reg_0, 0, 0) @[RegFile.scala 116:22]
    io.launch <= _T_214 @[RegFile.scala 116:13]
    io.vals[0] <= reg_2 @[RegFile.scala 119:16]
    node _T_215 = cat(reg_4, reg_3) @[Cat.scala 30:58]
    io.ptrs[0] <= _T_215 @[RegFile.scala 123:16]
    node _T_216 = cat(reg_6, reg_5) @[Cat.scala 30:58]
    io.ptrs[1] <= _T_216 @[RegFile.scala 123:16]
    node _T_217 = cat(reg_8, reg_7) @[Cat.scala 30:58]
    io.ptrs[2] <= _T_217 @[RegFile.scala 123:16]
    
  module Compute : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip launch : UInt<1>, finish : UInt<1>, ecnt : {valid : UInt<1>, bits : UInt<32>}[1], flip vals : UInt<32>[1], flip ptrs : UInt<64>[3], mem : {req : {valid : UInt<1>, opcode : UInt<1>, len : UInt<8>, addr : UInt<64>}, wr : {valid : UInt<1>, bits : UInt<64>}, flip rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    reg state : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Compute.scala 49:22]
    reg cycles : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[Compute.scala 51:23]
    reg reg1 : UInt<64>, clock @[Compute.scala 52:17]
    reg reg2 : UInt<64>, clock @[Compute.scala 53:17]
    reg cnt : UInt<32>, clock @[Compute.scala 54:16]
    reg raddr1 : UInt<64>, clock @[Compute.scala 55:19]
    reg raddr2 : UInt<64>, clock @[Compute.scala 56:19]
    reg waddr : UInt<64>, clock @[Compute.scala 57:18]
    node _T_82 = eq(UInt<3>("h00"), state) @[Conditional.scala 37:30]
    when _T_82 : @[Conditional.scala 40:58]
      when io.launch : @[Compute.scala 61:24]
        state <= UInt<3>("h01") @[Compute.scala 62:15]
        skip @[Compute.scala 61:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_83 = eq(UInt<3>("h01"), state) @[Conditional.scala 37:30]
      when _T_83 : @[Conditional.scala 39:67]
        state <= UInt<3>("h02") @[Compute.scala 66:13]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_84 = eq(UInt<3>("h02"), state) @[Conditional.scala 37:30]
        when _T_84 : @[Conditional.scala 39:67]
          when io.mem.rd.valid : @[Compute.scala 69:30]
            state <= UInt<3>("h03") @[Compute.scala 70:15]
            skip @[Compute.scala 69:30]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_85 = eq(UInt<3>("h03"), state) @[Conditional.scala 37:30]
          when _T_85 : @[Conditional.scala 39:67]
            state <= UInt<3>("h04") @[Compute.scala 74:13]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_86 = eq(UInt<3>("h04"), state) @[Conditional.scala 37:30]
            when _T_86 : @[Conditional.scala 39:67]
              when io.mem.rd.valid : @[Compute.scala 77:30]
                state <= UInt<3>("h05") @[Compute.scala 78:15]
                skip @[Compute.scala 77:30]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_87 = eq(UInt<3>("h05"), state) @[Conditional.scala 37:30]
              when _T_87 : @[Conditional.scala 39:67]
                state <= UInt<3>("h06") @[Compute.scala 82:13]
                skip @[Conditional.scala 39:67]
              else : @[Conditional.scala 39:67]
                node _T_88 = eq(UInt<3>("h06"), state) @[Conditional.scala 37:30]
                when _T_88 : @[Conditional.scala 39:67]
                  node _T_90 = sub(io.vals[0], UInt<1>("h01")) @[Compute.scala 85:29]
                  node _T_91 = asUInt(_T_90) @[Compute.scala 85:29]
                  node _T_92 = tail(_T_91, 1) @[Compute.scala 85:29]
                  node _T_93 = eq(cnt, _T_92) @[Compute.scala 85:17]
                  when _T_93 : @[Compute.scala 85:37]
                    state <= UInt<3>("h00") @[Compute.scala 86:15]
                    skip @[Compute.scala 85:37]
                  else : @[Compute.scala 87:20]
                    state <= UInt<3>("h01") @[Compute.scala 88:15]
                    skip @[Compute.scala 87:20]
                  skip @[Conditional.scala 39:67]
    node _T_94 = eq(state, UInt<3>("h06")) @[Compute.scala 93:20]
    node _T_96 = sub(io.vals[0], UInt<1>("h01")) @[Compute.scala 93:54]
    node _T_97 = asUInt(_T_96) @[Compute.scala 93:54]
    node _T_98 = tail(_T_97, 1) @[Compute.scala 93:54]
    node _T_99 = eq(cnt, _T_98) @[Compute.scala 93:42]
    node last = and(_T_94, _T_99) @[Compute.scala 93:35]
    node _T_100 = eq(state, UInt<3>("h00")) @[Compute.scala 96:15]
    when _T_100 : @[Compute.scala 96:26]
      cycles <= UInt<1>("h00") @[Compute.scala 97:12]
      skip @[Compute.scala 96:26]
    else : @[Compute.scala 98:16]
      node _T_103 = add(cycles, UInt<1>("h01")) @[Compute.scala 99:22]
      node _T_104 = tail(_T_103, 1) @[Compute.scala 99:22]
      cycles <= _T_104 @[Compute.scala 99:12]
      skip @[Compute.scala 98:16]
    io.ecnt[0].valid <= last @[Compute.scala 102:20]
    io.ecnt[0].bits <= cycles @[Compute.scala 103:19]
    node _T_105 = eq(state, UInt<3>("h00")) @[Compute.scala 106:15]
    when _T_105 : @[Compute.scala 106:26]
      raddr1 <= io.ptrs[0] @[Compute.scala 107:12]
      raddr2 <= io.ptrs[1] @[Compute.scala 108:12]
      waddr <= io.ptrs[2] @[Compute.scala 109:11]
      skip @[Compute.scala 106:26]
    else : @[Compute.scala 110:38]
      node _T_106 = eq(state, UInt<3>("h06")) @[Compute.scala 110:22]
      when _T_106 : @[Compute.scala 110:38]
        node _T_108 = add(raddr1, UInt<4>("h08")) @[Compute.scala 111:22]
        node _T_109 = tail(_T_108, 1) @[Compute.scala 111:22]
        raddr1 <= _T_109 @[Compute.scala 111:12]
        node _T_111 = add(raddr2, UInt<4>("h08")) @[Compute.scala 112:22]
        node _T_112 = tail(_T_111, 1) @[Compute.scala 112:22]
        raddr2 <= _T_112 @[Compute.scala 112:12]
        node _T_114 = add(waddr, UInt<4>("h08")) @[Compute.scala 113:20]
        node _T_115 = tail(_T_114, 1) @[Compute.scala 113:20]
        waddr <= _T_115 @[Compute.scala 113:11]
        skip @[Compute.scala 110:38]
    node _T_116 = eq(state, UInt<3>("h01")) @[Compute.scala 117:29]
    node _T_117 = eq(state, UInt<3>("h03")) @[Compute.scala 117:51]
    node _T_118 = or(_T_116, _T_117) @[Compute.scala 117:43]
    node _T_119 = eq(state, UInt<3>("h05")) @[Compute.scala 117:73]
    node _T_120 = or(_T_118, _T_119) @[Compute.scala 117:65]
    io.mem.req.valid <= _T_120 @[Compute.scala 117:20]
    node _T_121 = eq(state, UInt<3>("h05")) @[Compute.scala 118:30]
    io.mem.req.opcode <= _T_121 @[Compute.scala 118:21]
    io.mem.req.len <= UInt<1>("h00") @[Compute.scala 119:18]
    node _T_123 = eq(state, UInt<3>("h01")) @[Compute.scala 120:32]
    node _T_124 = eq(state, UInt<3>("h03")) @[Compute.scala 120:54]
    node _T_125 = or(_T_123, _T_124) @[Compute.scala 120:46]
    node _T_126 = eq(state, UInt<3>("h01")) @[Compute.scala 120:79]
    node _T_127 = mux(_T_126, raddr1, raddr2) @[Compute.scala 120:72]
    node _T_128 = mux(_T_125, _T_127, waddr) @[Compute.scala 120:25]
    io.mem.req.addr <= _T_128 @[Compute.scala 120:19]
    node _T_129 = eq(state, UInt<3>("h02")) @[Compute.scala 123:15]
    node _T_130 = and(_T_129, io.mem.rd.valid) @[Compute.scala 123:30]
    when _T_130 : @[Compute.scala 123:50]
      reg1 <= io.mem.rd.bits @[Compute.scala 124:10]
      skip @[Compute.scala 123:50]
    node _T_131 = eq(state, UInt<3>("h03")) @[Compute.scala 126:15]
    node _T_132 = and(_T_131, io.mem.rd.valid) @[Compute.scala 126:29]
    when _T_132 : @[Compute.scala 126:49]
      reg2 <= io.mem.rd.bits @[Compute.scala 127:10]
      skip @[Compute.scala 126:49]
    node _T_133 = eq(state, UInt<3>("h02")) @[Compute.scala 129:28]
    node _T_134 = eq(state, UInt<3>("h04")) @[Compute.scala 129:51]
    node _T_135 = or(_T_133, _T_134) @[Compute.scala 129:43]
    io.mem.rd.ready <= _T_135 @[Compute.scala 129:19]
    node _T_136 = eq(state, UInt<3>("h06")) @[Compute.scala 132:28]
    io.mem.wr.valid <= _T_136 @[Compute.scala 132:19]
    node _T_137 = add(reg1, reg2) @[Compute.scala 133:26]
    node _T_138 = tail(_T_137, 1) @[Compute.scala 133:26]
    io.mem.wr.bits <= _T_138 @[Compute.scala 133:18]
    node _T_139 = eq(state, UInt<3>("h00")) @[Compute.scala 136:15]
    when _T_139 : @[Compute.scala 136:26]
      cnt <= UInt<1>("h00") @[Compute.scala 137:9]
      skip @[Compute.scala 136:26]
    else : @[Compute.scala 138:38]
      node _T_141 = eq(state, UInt<3>("h06")) @[Compute.scala 138:22]
      when _T_141 : @[Compute.scala 138:38]
        node _T_143 = add(cnt, UInt<1>("h01")) @[Compute.scala 139:16]
        node _T_144 = tail(_T_143, 1) @[Compute.scala 139:16]
        cnt <= _T_144 @[Compute.scala 139:9]
        skip @[Compute.scala 138:38]
    io.finish <= last @[Compute.scala 143:13]
    
  module Accel : 
    input clock : Clock
    input reset : UInt<1>
    output io : {host : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip addr : UInt<8>, flip value : UInt<32>, deq : UInt<1>}, resp : {valid : UInt<1>, bits : UInt<32>}}, mem : {req : {valid : UInt<1>, opcode : UInt<1>, len : UInt<8>, addr : UInt<64>}, wr : {valid : UInt<1>, bits : UInt<64>}, flip rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    inst rf of RegFile @[Accel.scala 53:18]
    rf.clock <= clock
    rf.reset <= reset
    inst ce of Compute @[Accel.scala 54:18]
    ce.clock <= clock
    ce.reset <= reset
    io.host.resp.bits <= rf.io.host.resp.bits @[Accel.scala 55:14]
    io.host.resp.valid <= rf.io.host.resp.valid @[Accel.scala 55:14]
    io.host.req.deq <= rf.io.host.req.deq @[Accel.scala 55:14]
    rf.io.host.req.value <= io.host.req.value @[Accel.scala 55:14]
    rf.io.host.req.addr <= io.host.req.addr @[Accel.scala 55:14]
    rf.io.host.req.opcode <= io.host.req.opcode @[Accel.scala 55:14]
    rf.io.host.req.valid <= io.host.req.valid @[Accel.scala 55:14]
    ce.io.mem.rd.bits <= io.mem.rd.bits @[Accel.scala 56:10]
    ce.io.mem.rd.valid <= io.mem.rd.valid @[Accel.scala 56:10]
    io.mem.rd.ready <= ce.io.mem.rd.ready @[Accel.scala 56:10]
    io.mem.wr.bits <= ce.io.mem.wr.bits @[Accel.scala 56:10]
    io.mem.wr.valid <= ce.io.mem.wr.valid @[Accel.scala 56:10]
    io.mem.req.addr <= ce.io.mem.req.addr @[Accel.scala 56:10]
    io.mem.req.len <= ce.io.mem.req.len @[Accel.scala 56:10]
    io.mem.req.opcode <= ce.io.mem.req.opcode @[Accel.scala 56:10]
    io.mem.req.valid <= ce.io.mem.req.valid @[Accel.scala 56:10]
    ce.io.launch <= rf.io.launch @[Accel.scala 57:16]
    rf.io.finish <= ce.io.finish @[Accel.scala 58:16]
    rf.io.ecnt[0].bits <= ce.io.ecnt[0].bits @[Accel.scala 59:14]
    rf.io.ecnt[0].valid <= ce.io.ecnt[0].valid @[Accel.scala 59:14]
    ce.io.vals[0] <= rf.io.vals[0] @[Accel.scala 60:14]
    ce.io.ptrs[0] <= rf.io.ptrs[0] @[Accel.scala 61:14]
    ce.io.ptrs[1] <= rf.io.ptrs[1] @[Accel.scala 61:14]
    ce.io.ptrs[2] <= rf.io.ptrs[2] @[Accel.scala 61:14]
    
  module TestAccel : 
    input clock : Clock
    input reset : UInt<1>
    output io : {}
    
    inst sim_shell of VTASimShell @[TestAccel.scala 53:25]
    sim_shell.clock <= clock
    sim_shell.reset <= reset
    inst vta_accel of Accel @[TestAccel.scala 54:25]
    vta_accel.clock <= clock
    vta_accel.reset <= reset
    sim_shell.io.host.resp.bits <= vta_accel.io.host.resp.bits @[TestAccel.scala 55:21]
    sim_shell.io.host.resp.valid <= vta_accel.io.host.resp.valid @[TestAccel.scala 55:21]
    sim_shell.io.host.req.deq <= vta_accel.io.host.req.deq @[TestAccel.scala 55:21]
    vta_accel.io.host.req.value <= sim_shell.io.host.req.value @[TestAccel.scala 55:21]
    vta_accel.io.host.req.addr <= sim_shell.io.host.req.addr @[TestAccel.scala 55:21]
    vta_accel.io.host.req.opcode <= sim_shell.io.host.req.opcode @[TestAccel.scala 55:21]
    vta_accel.io.host.req.valid <= sim_shell.io.host.req.valid @[TestAccel.scala 55:21]
    vta_accel.io.mem.rd.bits <= sim_shell.io.mem.rd.bits @[TestAccel.scala 56:20]
    vta_accel.io.mem.rd.valid <= sim_shell.io.mem.rd.valid @[TestAccel.scala 56:20]
    sim_shell.io.mem.rd.ready <= vta_accel.io.mem.rd.ready @[TestAccel.scala 56:20]
    sim_shell.io.mem.wr.bits <= vta_accel.io.mem.wr.bits @[TestAccel.scala 56:20]
    sim_shell.io.mem.wr.valid <= vta_accel.io.mem.wr.valid @[TestAccel.scala 56:20]
    sim_shell.io.mem.req.addr <= vta_accel.io.mem.req.addr @[TestAccel.scala 56:20]
    sim_shell.io.mem.req.len <= vta_accel.io.mem.req.len @[TestAccel.scala 56:20]
    sim_shell.io.mem.req.opcode <= vta_accel.io.mem.req.opcode @[TestAccel.scala 56:20]
    sim_shell.io.mem.req.valid <= vta_accel.io.mem.req.valid @[TestAccel.scala 56:20]
    
