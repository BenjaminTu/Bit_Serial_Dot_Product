;buildInfoPackage: chisel3, version: 3.1.7, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-03-20 22:15:13.399, builtAtMillis: 1553120113399
circuit Test : 
  module DotGen : 
    input clock : Clock
    input reset : UInt<1>
    output io : {a : UInt<4>[5], b : UInt<4>[5], flip y : UInt<12>, rst : UInt<1>}
    
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 26:33]
    when UInt<1>("h01") : @[Counter.scala 63:17]
      node _T_53 = eq(value, UInt<8>("h0ff")) @[Counter.scala 34:24]
      node _T_55 = add(value, UInt<1>("h01")) @[Counter.scala 35:22]
      node _T_56 = tail(_T_55, 1) @[Counter.scala 35:22]
      value <= _T_56 @[Counter.scala 35:13]
      skip @[Counter.scala 63:17]
    node _T_57 = and(UInt<1>("h01"), _T_53) @[Counter.scala 64:20]
    node _T_59 = rem(value, UInt<4>("h0f")) @[Test.scala 61:13]
    node _T_61 = lt(_T_59, UInt<3>("h07")) @[Test.scala 61:20]
    when _T_61 : @[Test.scala 61:27]
      wire _T_70 : UInt<3>[5] @[Test.scala 62:32]
      _T_70[0] <= UInt<3>("h06") @[Test.scala 62:32]
      _T_70[1] <= UInt<3>("h06") @[Test.scala 62:32]
      _T_70[2] <= UInt<3>("h06") @[Test.scala 62:32]
      _T_70[3] <= UInt<3>("h06") @[Test.scala 62:32]
      _T_70[4] <= UInt<3>("h06") @[Test.scala 62:32]
      io.a[0] <= _T_70[0] @[Test.scala 62:22]
      io.a[1] <= _T_70[1] @[Test.scala 62:22]
      io.a[2] <= _T_70[2] @[Test.scala 62:22]
      io.a[3] <= _T_70[3] @[Test.scala 62:22]
      io.a[4] <= _T_70[4] @[Test.scala 62:22]
      wire _T_86 : UInt<3>[5] @[Test.scala 63:32]
      _T_86[0] <= UInt<3>("h05") @[Test.scala 63:32]
      _T_86[1] <= UInt<3>("h05") @[Test.scala 63:32]
      _T_86[2] <= UInt<3>("h05") @[Test.scala 63:32]
      _T_86[3] <= UInt<3>("h05") @[Test.scala 63:32]
      _T_86[4] <= UInt<3>("h05") @[Test.scala 63:32]
      io.b[0] <= _T_86[0] @[Test.scala 63:22]
      io.b[1] <= _T_86[1] @[Test.scala 63:22]
      io.b[2] <= _T_86[2] @[Test.scala 63:22]
      io.b[3] <= _T_86[3] @[Test.scala 63:22]
      io.b[4] <= _T_86[4] @[Test.scala 63:22]
      skip @[Test.scala 61:27]
    else : @[Test.scala 64:28]
      wire _T_102 : UInt<4>[5] @[Test.scala 65:20]
      _T_102[0] <= UInt<4>("h0a") @[Test.scala 65:20]
      _T_102[1] <= UInt<4>("h0a") @[Test.scala 65:20]
      _T_102[2] <= UInt<4>("h0a") @[Test.scala 65:20]
      _T_102[3] <= UInt<4>("h0a") @[Test.scala 65:20]
      _T_102[4] <= UInt<4>("h0a") @[Test.scala 65:20]
      io.a[0] <= _T_102[0] @[Test.scala 65:10]
      io.a[1] <= _T_102[1] @[Test.scala 65:10]
      io.a[2] <= _T_102[2] @[Test.scala 65:10]
      io.a[3] <= _T_102[3] @[Test.scala 65:10]
      io.a[4] <= _T_102[4] @[Test.scala 65:10]
      wire _T_118 : UInt<4>[5] @[Test.scala 66:20]
      _T_118[0] <= UInt<4>("h0c") @[Test.scala 66:20]
      _T_118[1] <= UInt<4>("h0c") @[Test.scala 66:20]
      _T_118[2] <= UInt<4>("h0c") @[Test.scala 66:20]
      _T_118[3] <= UInt<4>("h0c") @[Test.scala 66:20]
      _T_118[4] <= UInt<4>("h0c") @[Test.scala 66:20]
      io.b[0] <= _T_118[0] @[Test.scala 66:10]
      io.b[1] <= _T_118[1] @[Test.scala 66:10]
      io.b[2] <= _T_118[2] @[Test.scala 66:10]
      io.b[3] <= _T_118[3] @[Test.scala 66:10]
      io.b[4] <= _T_118[4] @[Test.scala 66:10]
      skip @[Test.scala 64:28]
    node _T_127 = rem(value, UInt<4>("h0f")) @[Test.scala 68:22]
    node _T_129 = eq(_T_127, UInt<3>("h07")) @[Test.scala 68:28]
    io.rst <= _T_129 @[Test.scala 68:16]
    when UInt<1>("h01") : @[Test.scala 72:23]
      node _T_131 = bits(reset, 0, 0) @[Test.scala 73:23]
      node _T_133 = eq(_T_131, UInt<1>("h00")) @[Test.scala 73:23]
      when _T_133 : @[Test.scala 73:23]
        printf(clock, UInt<1>(1), "\noverall RST: %d \n", io.rst) @[Test.scala 73:23]
        skip @[Test.scala 73:23]
      node _T_134 = bits(reset, 0, 0) @[Test.scala 74:23]
      node _T_136 = eq(_T_134, UInt<1>("h00")) @[Test.scala 74:23]
      when _T_136 : @[Test.scala 74:23]
        printf(clock, UInt<1>(1), "arrA: ") @[Test.scala 74:23]
        skip @[Test.scala 74:23]
      node _T_137 = bits(reset, 0, 0) @[Test.scala 76:14]
      node _T_139 = eq(_T_137, UInt<1>("h00")) @[Test.scala 76:14]
      when _T_139 : @[Test.scala 76:14]
        printf(clock, UInt<1>(1), "%d, ", io.a[0]) @[Test.scala 76:14]
        skip @[Test.scala 76:14]
      node _T_140 = bits(reset, 0, 0) @[Test.scala 76:14]
      node _T_142 = eq(_T_140, UInt<1>("h00")) @[Test.scala 76:14]
      when _T_142 : @[Test.scala 76:14]
        printf(clock, UInt<1>(1), "%d, ", io.a[1]) @[Test.scala 76:14]
        skip @[Test.scala 76:14]
      node _T_143 = bits(reset, 0, 0) @[Test.scala 76:14]
      node _T_145 = eq(_T_143, UInt<1>("h00")) @[Test.scala 76:14]
      when _T_145 : @[Test.scala 76:14]
        printf(clock, UInt<1>(1), "%d, ", io.a[2]) @[Test.scala 76:14]
        skip @[Test.scala 76:14]
      node _T_146 = bits(reset, 0, 0) @[Test.scala 76:14]
      node _T_148 = eq(_T_146, UInt<1>("h00")) @[Test.scala 76:14]
      when _T_148 : @[Test.scala 76:14]
        printf(clock, UInt<1>(1), "%d, ", io.a[3]) @[Test.scala 76:14]
        skip @[Test.scala 76:14]
      node _T_149 = bits(reset, 0, 0) @[Test.scala 76:14]
      node _T_151 = eq(_T_149, UInt<1>("h00")) @[Test.scala 76:14]
      when _T_151 : @[Test.scala 76:14]
        printf(clock, UInt<1>(1), "%d, ", io.a[4]) @[Test.scala 76:14]
        skip @[Test.scala 76:14]
      node _T_152 = bits(reset, 0, 0) @[Test.scala 78:23]
      node _T_154 = eq(_T_152, UInt<1>("h00")) @[Test.scala 78:23]
      when _T_154 : @[Test.scala 78:23]
        printf(clock, UInt<1>(1), "\narrB: ") @[Test.scala 78:23]
        skip @[Test.scala 78:23]
      node _T_155 = bits(reset, 0, 0) @[Test.scala 80:14]
      node _T_157 = eq(_T_155, UInt<1>("h00")) @[Test.scala 80:14]
      when _T_157 : @[Test.scala 80:14]
        printf(clock, UInt<1>(1), "%d, ", io.b[0]) @[Test.scala 80:14]
        skip @[Test.scala 80:14]
      node _T_158 = bits(reset, 0, 0) @[Test.scala 80:14]
      node _T_160 = eq(_T_158, UInt<1>("h00")) @[Test.scala 80:14]
      when _T_160 : @[Test.scala 80:14]
        printf(clock, UInt<1>(1), "%d, ", io.b[1]) @[Test.scala 80:14]
        skip @[Test.scala 80:14]
      node _T_161 = bits(reset, 0, 0) @[Test.scala 80:14]
      node _T_163 = eq(_T_161, UInt<1>("h00")) @[Test.scala 80:14]
      when _T_163 : @[Test.scala 80:14]
        printf(clock, UInt<1>(1), "%d, ", io.b[2]) @[Test.scala 80:14]
        skip @[Test.scala 80:14]
      node _T_164 = bits(reset, 0, 0) @[Test.scala 80:14]
      node _T_166 = eq(_T_164, UInt<1>("h00")) @[Test.scala 80:14]
      when _T_166 : @[Test.scala 80:14]
        printf(clock, UInt<1>(1), "%d, ", io.b[3]) @[Test.scala 80:14]
        skip @[Test.scala 80:14]
      node _T_167 = bits(reset, 0, 0) @[Test.scala 80:14]
      node _T_169 = eq(_T_167, UInt<1>("h00")) @[Test.scala 80:14]
      when _T_169 : @[Test.scala 80:14]
        printf(clock, UInt<1>(1), "%d, ", io.b[4]) @[Test.scala 80:14]
        skip @[Test.scala 80:14]
      node _T_170 = bits(reset, 0, 0) @[Test.scala 82:23]
      node _T_172 = eq(_T_170, UInt<1>("h00")) @[Test.scala 82:23]
      when _T_172 : @[Test.scala 82:23]
        printf(clock, UInt<1>(1), "\n") @[Test.scala 82:23]
        skip @[Test.scala 82:23]
      skip @[Test.scala 72:23]
    
  module Dot : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rst : UInt<1>, flip a : UInt<4>[5], flip b : UInt<4>[5], valid : UInt<1>, y : UInt<12>}
    
    wire initVals : UInt<12>[5] @[VectorMult.scala 16:31]
    initVals[0] <= UInt<12>("h00") @[VectorMult.scala 16:31]
    initVals[1] <= UInt<12>("h00") @[VectorMult.scala 16:31]
    initVals[2] <= UInt<12>("h00") @[VectorMult.scala 16:31]
    initVals[3] <= UInt<12>("h00") @[VectorMult.scala 16:31]
    initVals[4] <= UInt<12>("h00") @[VectorMult.scala 16:31]
    reg accum : UInt<12>[5], clock with : (reset => (reset, initVals)) @[VectorMult.scala 17:22]
    reg valid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[VectorMult.scala 18:28]
    reg value : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Counter.scala 26:33]
    when UInt<1>("h01") : @[Counter.scala 63:17]
      node _T_105 = eq(value, UInt<3>("h04")) @[Counter.scala 34:24]
      node _T_107 = add(value, UInt<1>("h01")) @[Counter.scala 35:22]
      node _T_108 = tail(_T_107, 1) @[Counter.scala 35:22]
      value <= _T_108 @[Counter.scala 35:13]
      when _T_105 : @[Counter.scala 37:21]
        value <= UInt<1>("h00") @[Counter.scala 37:29]
        skip @[Counter.scala 37:21]
      skip @[Counter.scala 63:17]
    node _T_110 = and(UInt<1>("h01"), _T_105) @[Counter.scala 64:20]
    reg cont : UInt<1>, clock with : (reset => (reset, UInt<1>("h01"))) @[VectorMult.scala 20:27]
    when io.rst : @[VectorMult.scala 21:23]
      accum[0] <= initVals[0] @[VectorMult.scala 22:23]
      accum[1] <= initVals[1] @[VectorMult.scala 22:23]
      accum[2] <= initVals[2] @[VectorMult.scala 22:23]
      accum[3] <= initVals[3] @[VectorMult.scala 22:23]
      accum[4] <= initVals[4] @[VectorMult.scala 22:23]
      io.valid <= UInt<1>("h00") @[VectorMult.scala 23:26]
      cont <= UInt<1>("h01") @[VectorMult.scala 24:22]
      skip @[VectorMult.scala 21:23]
    else : @[VectorMult.scala 25:22]
      node _T_115 = mul(io.a[0], io.b[0]) @[VectorMult.scala 26:37]
      accum[0] <= _T_115 @[VectorMult.scala 26:26]
      node _T_116 = mul(io.a[1], io.b[1]) @[VectorMult.scala 28:44]
      node _T_117 = add(accum[0], _T_116) @[VectorMult.scala 28:32]
      accum[1] <= _T_117 @[VectorMult.scala 28:18]
      node _T_118 = mul(io.a[2], io.b[2]) @[VectorMult.scala 28:44]
      node _T_119 = add(accum[1], _T_118) @[VectorMult.scala 28:32]
      accum[2] <= _T_119 @[VectorMult.scala 28:18]
      node _T_120 = mul(io.a[3], io.b[3]) @[VectorMult.scala 28:44]
      node _T_121 = add(accum[2], _T_120) @[VectorMult.scala 28:32]
      accum[3] <= _T_121 @[VectorMult.scala 28:18]
      node _T_122 = mul(io.a[4], io.b[4]) @[VectorMult.scala 28:44]
      node _T_123 = add(accum[3], _T_122) @[VectorMult.scala 28:32]
      accum[4] <= _T_123 @[VectorMult.scala 28:18]
      when cont : @[VectorMult.scala 30:29]
        node _T_125 = eq(value, UInt<3>("h04")) @[VectorMult.scala 31:38]
        valid <= _T_125 @[VectorMult.scala 31:31]
        when valid : @[VectorMult.scala 32:38]
          cont <= UInt<1>("h00") @[VectorMult.scala 32:45]
          skip @[VectorMult.scala 32:38]
        skip @[VectorMult.scala 30:29]
      else : @[VectorMult.scala 33:30]
        valid <= UInt<1>("h00") @[VectorMult.scala 34:31]
        skip @[VectorMult.scala 33:30]
      skip @[VectorMult.scala 25:22]
    node _T_128 = bits(reset, 0, 0) @[VectorMult.scala 37:15]
    node _T_130 = eq(_T_128, UInt<1>("h00")) @[VectorMult.scala 37:15]
    when _T_130 : @[VectorMult.scala 37:15]
      printf(clock, UInt<1>(1), "\ncont: %d\n", cont) @[VectorMult.scala 37:15]
      skip @[VectorMult.scala 37:15]
    node _T_131 = bits(reset, 0, 0) @[VectorMult.scala 38:15]
    node _T_133 = eq(_T_131, UInt<1>("h00")) @[VectorMult.scala 38:15]
    when _T_133 : @[VectorMult.scala 38:15]
      printf(clock, UInt<1>(1), "\ndata valid: %d, current cnt: %d \n", valid, value) @[VectorMult.scala 38:15]
      skip @[VectorMult.scala 38:15]
    io.valid <= valid @[VectorMult.scala 39:18]
    io.y <= accum[4] @[VectorMult.scala 40:8]
    
  module Shift : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<13>, flip shift : UInt<5>, out : UInt<18>}
    
    node _T_11 = dshl(io.in, io.shift) @[VectorMult.scala 96:25]
    io.out <= _T_11 @[VectorMult.scala 96:16]
    node _T_12 = bits(reset, 0, 0) @[VectorMult.scala 97:15]
    node _T_14 = eq(_T_12, UInt<1>("h00")) @[VectorMult.scala 97:15]
    when _T_14 : @[VectorMult.scala 97:15]
      printf(clock, UInt<1>(1), "io.shiftin: %d \n", io.in) @[VectorMult.scala 97:15]
      skip @[VectorMult.scala 97:15]
    node _T_15 = bits(reset, 0, 0) @[VectorMult.scala 98:15]
    node _T_17 = eq(_T_15, UInt<1>("h00")) @[VectorMult.scala 98:15]
    when _T_17 : @[VectorMult.scala 98:15]
      printf(clock, UInt<1>(1), "io.shift: %d \n", io.shift) @[VectorMult.scala 98:15]
      skip @[VectorMult.scala 98:15]
    node _T_18 = bits(reset, 0, 0) @[VectorMult.scala 99:15]
    node _T_20 = eq(_T_18, UInt<1>("h00")) @[VectorMult.scala 99:15]
    when _T_20 : @[VectorMult.scala 99:15]
      printf(clock, UInt<1>(1), "io.shiftout: %d \n", io.out) @[VectorMult.scala 99:15]
      skip @[VectorMult.scala 99:15]
    
  module Accumulator : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rst : UInt<1>, flip valid : UInt<1>, flip in : UInt<17>, sum : UInt<18>}
    
    reg reg : UInt<18>, clock with : (reset => (reset, UInt<18>("h00"))) @[VectorMult.scala 77:26]
    when io.rst : @[VectorMult.scala 78:23]
      reg <= UInt<1>("h00") @[VectorMult.scala 79:21]
      skip @[VectorMult.scala 78:23]
    else : @[VectorMult.scala 80:32]
      when io.valid : @[VectorMult.scala 80:32]
        node _T_16 = add(reg, io.in) @[VectorMult.scala 81:28]
        reg <= _T_16 @[VectorMult.scala 81:21]
        skip @[VectorMult.scala 80:32]
    io.sum <= reg @[VectorMult.scala 83:16]
    node _T_17 = bits(reset, 0, 0) @[VectorMult.scala 84:9]
    node _T_19 = eq(_T_17, UInt<1>("h00")) @[VectorMult.scala 84:9]
    when _T_19 : @[VectorMult.scala 84:9]
      printf(clock, UInt<1>(1), "io.datavalid: %d \n", io.valid) @[VectorMult.scala 84:9]
      skip @[VectorMult.scala 84:9]
    node _T_20 = bits(reset, 0, 0) @[VectorMult.scala 85:9]
    node _T_22 = eq(_T_20, UInt<1>("h00")) @[VectorMult.scala 85:9]
    when _T_22 : @[VectorMult.scala 85:9]
      printf(clock, UInt<1>(1), "io.accumin: %d \n", io.in) @[VectorMult.scala 85:9]
      skip @[VectorMult.scala 85:9]
    node _T_23 = bits(reset, 0, 0) @[VectorMult.scala 86:9]
    node _T_25 = eq(_T_23, UInt<1>("h00")) @[VectorMult.scala 86:9]
    when _T_25 : @[VectorMult.scala 86:9]
      printf(clock, UInt<1>(1), "io.sum: %d \n", io.sum) @[VectorMult.scala 86:9]
      skip @[VectorMult.scala 86:9]
    
  module Top : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rst : UInt<1>, flip arrA : UInt<4>[5], flip arrB : UInt<4>[5], flip shift : UInt<5>, dot : UInt<18>}
    
    inst computeDot of Dot @[VectorMult.scala 114:32]
    computeDot.clock <= clock
    computeDot.reset <= reset
    inst shifter of Shift @[VectorMult.scala 115:29]
    shifter.clock <= clock
    shifter.reset <= reset
    inst accumulator of Accumulator @[VectorMult.scala 116:33]
    accumulator.clock <= clock
    accumulator.reset <= reset
    computeDot.io.rst <= io.rst @[VectorMult.scala 117:27]
    computeDot.io.a[0] <= io.arrA[0] @[VectorMult.scala 118:25]
    computeDot.io.a[1] <= io.arrA[1] @[VectorMult.scala 118:25]
    computeDot.io.a[2] <= io.arrA[2] @[VectorMult.scala 118:25]
    computeDot.io.a[3] <= io.arrA[3] @[VectorMult.scala 118:25]
    computeDot.io.a[4] <= io.arrA[4] @[VectorMult.scala 118:25]
    computeDot.io.b[0] <= io.arrB[0] @[VectorMult.scala 119:25]
    computeDot.io.b[1] <= io.arrB[1] @[VectorMult.scala 119:25]
    computeDot.io.b[2] <= io.arrB[2] @[VectorMult.scala 119:25]
    computeDot.io.b[3] <= io.arrB[3] @[VectorMult.scala 119:25]
    computeDot.io.b[4] <= io.arrB[4] @[VectorMult.scala 119:25]
    accumulator.io.rst <= io.rst @[VectorMult.scala 120:28]
    accumulator.io.valid <= computeDot.io.valid @[VectorMult.scala 121:30]
    shifter.io.in <= computeDot.io.y @[VectorMult.scala 122:23]
    shifter.io.shift <= io.shift @[VectorMult.scala 123:26]
    accumulator.io.in <= shifter.io.out @[VectorMult.scala 124:27]
    io.dot <= accumulator.io.sum @[VectorMult.scala 125:16]
    
  module OneNumGen : 
    input clock : Clock
    input reset : UInt<1>
    output io : {num : UInt<32>}
    
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 26:33]
    when UInt<1>("h01") : @[Counter.scala 63:17]
      node _T_11 = eq(value, UInt<8>("h0ff")) @[Counter.scala 34:24]
      node _T_13 = add(value, UInt<1>("h01")) @[Counter.scala 35:22]
      node _T_14 = tail(_T_13, 1) @[Counter.scala 35:22]
      value <= _T_14 @[Counter.scala 35:13]
      skip @[Counter.scala 63:17]
    node _T_15 = and(UInt<1>("h01"), _T_11) @[Counter.scala 64:20]
    io.num <= UInt<2>("h03") @[Test.scala 93:16]
    
  module PrintNum : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip num : UInt<64>}
    
    node _T_7 = bits(reset, 0, 0) @[Test.scala 130:15]
    node _T_9 = eq(_T_7, UInt<1>("h00")) @[Test.scala 130:15]
    when _T_9 : @[Test.scala 130:15]
      printf(clock, UInt<1>(1), "\nresult: %d\n", io.num) @[Test.scala 130:15]
      skip @[Test.scala 130:15]
    
  module Test : 
    input clock : Clock
    input reset : UInt<1>
    output io : {}
    
    inst DotGen of DotGen @[Test.scala 164:42]
    DotGen.clock <= clock
    DotGen.reset <= reset
    inst Top of Top @[Test.scala 165:41]
    Top.clock <= clock
    Top.reset <= reset
    inst OneNumGen of OneNumGen @[Test.scala 166:44]
    OneNumGen.clock <= clock
    OneNumGen.reset <= reset
    inst PrintNum of PrintNum @[Test.scala 167:42]
    PrintNum.clock <= clock
    PrintNum.reset <= reset
    Top.io.rst <= UInt<1>("h00") @[Test.scala 168:36]
    Top.io.arrA[0] <= DotGen.io.a[0] @[Test.scala 169:37]
    Top.io.arrA[1] <= DotGen.io.a[1] @[Test.scala 169:37]
    Top.io.arrA[2] <= DotGen.io.a[2] @[Test.scala 169:37]
    Top.io.arrA[3] <= DotGen.io.a[3] @[Test.scala 169:37]
    Top.io.arrA[4] <= DotGen.io.a[4] @[Test.scala 169:37]
    Top.io.arrB[0] <= DotGen.io.b[0] @[Test.scala 170:37]
    Top.io.arrB[1] <= DotGen.io.b[1] @[Test.scala 170:37]
    Top.io.arrB[2] <= DotGen.io.b[2] @[Test.scala 170:37]
    Top.io.arrB[3] <= DotGen.io.b[3] @[Test.scala 170:37]
    Top.io.arrB[4] <= DotGen.io.b[4] @[Test.scala 170:37]
    Top.io.shift <= OneNumGen.io.num @[Test.scala 171:38]
    DotGen.io.y <= Top.io.dot @[Test.scala 172:35]
    PrintNum.io.num <= Top.io.dot @[Test.scala 173:37]
    
